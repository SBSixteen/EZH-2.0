{"ast":null,"code":"import { callbackifyPromiseWithTimeout, getDataFromArgs } from './utils.js';\nexport function makeAutoPaginationMethods(self, requestArgs, spec, firstPagePromise) {\n  const promiseCache = {\n    currentPromise: null\n  };\n  const reverseIteration = isReverseIteration(requestArgs);\n  let pagePromise = firstPagePromise;\n  let i = 0;\n  // Search and List methods iterate differently.\n  // Search relies on a `next_page` token and can only iterate in one direction.\n  // List relies on either an `ending_before` or `starting_after` field with\n  // an item ID to paginate and is bi-directional.\n  //\n  // Please note: spec.methodType === 'search' is beta functionality and is\n  // subject to change/removal at any time.\n  let getNextPagePromise;\n  if (spec.methodType === 'search') {\n    getNextPagePromise = pageResult => {\n      if (!pageResult.next_page) {\n        throw Error('Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.');\n      }\n      return self._makeRequest(requestArgs, spec, {\n        page: pageResult.next_page\n      });\n    };\n  } else {\n    getNextPagePromise = pageResult => {\n      const lastId = getLastId(pageResult, reverseIteration);\n      return self._makeRequest(requestArgs, spec, {\n        [reverseIteration ? 'ending_before' : 'starting_after']: lastId\n      });\n    };\n  }\n  function iterate(pageResult) {\n    if (!(pageResult && pageResult.data && typeof pageResult.data.length === 'number')) {\n      throw Error('Unexpected: Stripe API response does not have a well-formed `data` array.');\n    }\n    if (i < pageResult.data.length) {\n      const idx = reverseIteration ? pageResult.data.length - 1 - i : i;\n      const value = pageResult.data[idx];\n      i += 1;\n      return {\n        value,\n        done: false\n      };\n    } else if (pageResult.has_more) {\n      // Reset counter, request next page, and recurse.\n      i = 0;\n      pagePromise = getNextPagePromise(pageResult);\n      return pagePromise.then(iterate);\n    }\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n  function asyncIteratorNext() {\n    return memoizedPromise(promiseCache, (resolve, reject) => {\n      return pagePromise.then(iterate).then(resolve).catch(reject);\n    });\n  }\n  const autoPagingEach = makeAutoPagingEach(asyncIteratorNext);\n  const autoPagingToArray = makeAutoPagingToArray(autoPagingEach);\n  const autoPaginationMethods = {\n    autoPagingEach,\n    autoPagingToArray,\n    // Async iterator functions:\n    next: asyncIteratorNext,\n    return: () => {\n      // This is required for `break`.\n      return {};\n    },\n    [getAsyncIteratorSymbol()]: () => {\n      return autoPaginationMethods;\n    }\n  };\n  return autoPaginationMethods;\n}\n/**\n * ----------------\n * Private Helpers:\n * ----------------\n */\nfunction getAsyncIteratorSymbol() {\n  if (typeof Symbol !== 'undefined' && Symbol.asyncIterator) {\n    return Symbol.asyncIterator;\n  }\n  // Follow the convention from libraries like iterall: https://github.com/leebyron/iterall#asynciterator-1\n  return '@@asyncIterator';\n}\nfunction getDoneCallback(args) {\n  if (args.length < 2) {\n    return null;\n  }\n  const onDone = args[1];\n  if (typeof onDone !== 'function') {\n    throw Error(`The second argument to autoPagingEach, if present, must be a callback function; received ${typeof onDone}`);\n  }\n  return onDone;\n}\n/**\n * We allow four forms of the `onItem` callback (the middle two being equivalent),\n *\n *   1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n *   2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n *   3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n *   4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n *\n * In addition to standard validation, this helper\n * coalesces the former forms into the latter form.\n */\nfunction getItemCallback(args) {\n  if (args.length === 0) {\n    return undefined;\n  }\n  const onItem = args[0];\n  if (typeof onItem !== 'function') {\n    throw Error(`The first argument to autoPagingEach, if present, must be a callback function; received ${typeof onItem}`);\n  }\n  // 4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n  if (onItem.length === 2) {\n    return onItem;\n  }\n  if (onItem.length > 2) {\n    throw Error(`The \\`onItem\\` callback function passed to autoPagingEach must accept at most two arguments; got ${onItem}`);\n  }\n  // This magically handles all three of these usecases (the latter two being functionally identical):\n  // 1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n  // 2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n  // 3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n  return function _onItem(item, next) {\n    const shouldContinue = onItem(item);\n    next(shouldContinue);\n  };\n}\nfunction getLastId(listResult, reverseIteration) {\n  const lastIdx = reverseIteration ? 0 : listResult.data.length - 1;\n  const lastItem = listResult.data[lastIdx];\n  const lastId = lastItem && lastItem.id;\n  if (!lastId) {\n    throw Error('Unexpected: No `id` found on the last item while auto-paging a list.');\n  }\n  return lastId;\n}\n/**\n * If a user calls `.next()` multiple times in parallel,\n * return the same result until something has resolved\n * to prevent page-turning race conditions.\n */\nfunction memoizedPromise(promiseCache, cb) {\n  if (promiseCache.currentPromise) {\n    return promiseCache.currentPromise;\n  }\n  promiseCache.currentPromise = new Promise(cb).then(ret => {\n    promiseCache.currentPromise = undefined;\n    return ret;\n  });\n  return promiseCache.currentPromise;\n}\nfunction makeAutoPagingEach(asyncIteratorNext) {\n  return function autoPagingEach( /* onItem?, onDone? */\n  ) {\n    const args = [].slice.call(arguments);\n    const onItem = getItemCallback(args);\n    const onDone = getDoneCallback(args);\n    if (args.length > 2) {\n      throw Error(`autoPagingEach takes up to two arguments; received ${args}`);\n    }\n    const autoPagePromise = wrapAsyncIteratorWithCallback(asyncIteratorNext,\n    // @ts-ignore we might need a null check\n    onItem);\n    return callbackifyPromiseWithTimeout(autoPagePromise, onDone);\n  };\n}\nfunction makeAutoPagingToArray(autoPagingEach) {\n  return function autoPagingToArray(opts, onDone) {\n    const limit = opts && opts.limit;\n    if (!limit) {\n      throw Error('You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.');\n    }\n    if (limit > 10000) {\n      throw Error('You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.');\n    }\n    const promise = new Promise((resolve, reject) => {\n      const items = [];\n      autoPagingEach(item => {\n        items.push(item);\n        if (items.length >= limit) {\n          return false;\n        }\n      }).then(() => {\n        resolve(items);\n      }).catch(reject);\n    });\n    // @ts-ignore\n    return callbackifyPromiseWithTimeout(promise, onDone);\n  };\n}\nfunction wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {\n  return new Promise((resolve, reject) => {\n    function handleIteration(iterResult) {\n      if (iterResult.done) {\n        resolve();\n        return;\n      }\n      const item = iterResult.value;\n      return new Promise(next => {\n        // Bit confusing, perhaps; we pass a `resolve` fn\n        // to the user, so they can decide when and if to continue.\n        // They can return false, or a promise which resolves to false, to break.\n        onItem(item, next);\n      }).then(shouldContinue => {\n        if (shouldContinue === false) {\n          return handleIteration({\n            done: true\n          });\n        } else {\n          return asyncIteratorNext().then(handleIteration);\n        }\n      });\n    }\n    asyncIteratorNext().then(handleIteration).catch(reject);\n  });\n}\nfunction isReverseIteration(requestArgs) {\n  const args = [].slice.call(requestArgs);\n  const dataFromArgs = getDataFromArgs(args);\n  return !!dataFromArgs.ending_before;\n}","map":{"version":3,"names":["callbackifyPromiseWithTimeout","getDataFromArgs","makeAutoPaginationMethods","self","requestArgs","spec","firstPagePromise","promiseCache","currentPromise","reverseIteration","isReverseIteration","pagePromise","i","getNextPagePromise","methodType","pageResult","next_page","Error","_makeRequest","page","lastId","getLastId","iterate","data","length","idx","value","done","has_more","then","undefined","asyncIteratorNext","memoizedPromise","resolve","reject","catch","autoPagingEach","makeAutoPagingEach","autoPagingToArray","makeAutoPagingToArray","autoPaginationMethods","next","return","getAsyncIteratorSymbol","Symbol","asyncIterator","getDoneCallback","args","onDone","getItemCallback","onItem","_onItem","item","shouldContinue","listResult","lastIdx","lastItem","id","cb","Promise","ret","slice","call","arguments","autoPagePromise","wrapAsyncIteratorWithCallback","opts","limit","promise","items","push","handleIteration","iterResult","dataFromArgs","ending_before"],"sources":["C:/Users/szihy/OneDrive/Desktop/EZH-2.0/node_modules/stripe/esm/autoPagination.js"],"sourcesContent":["import { callbackifyPromiseWithTimeout, getDataFromArgs } from './utils.js';\nexport function makeAutoPaginationMethods(self, requestArgs, spec, firstPagePromise) {\n    const promiseCache = { currentPromise: null };\n    const reverseIteration = isReverseIteration(requestArgs);\n    let pagePromise = firstPagePromise;\n    let i = 0;\n    // Search and List methods iterate differently.\n    // Search relies on a `next_page` token and can only iterate in one direction.\n    // List relies on either an `ending_before` or `starting_after` field with\n    // an item ID to paginate and is bi-directional.\n    //\n    // Please note: spec.methodType === 'search' is beta functionality and is\n    // subject to change/removal at any time.\n    let getNextPagePromise;\n    if (spec.methodType === 'search') {\n        getNextPagePromise = (pageResult) => {\n            if (!pageResult.next_page) {\n                throw Error('Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.');\n            }\n            return self._makeRequest(requestArgs, spec, {\n                page: pageResult.next_page,\n            });\n        };\n    }\n    else {\n        getNextPagePromise = (pageResult) => {\n            const lastId = getLastId(pageResult, reverseIteration);\n            return self._makeRequest(requestArgs, spec, {\n                [reverseIteration ? 'ending_before' : 'starting_after']: lastId,\n            });\n        };\n    }\n    function iterate(pageResult) {\n        if (!(pageResult &&\n            pageResult.data &&\n            typeof pageResult.data.length === 'number')) {\n            throw Error('Unexpected: Stripe API response does not have a well-formed `data` array.');\n        }\n        if (i < pageResult.data.length) {\n            const idx = reverseIteration ? pageResult.data.length - 1 - i : i;\n            const value = pageResult.data[idx];\n            i += 1;\n            return { value, done: false };\n        }\n        else if (pageResult.has_more) {\n            // Reset counter, request next page, and recurse.\n            i = 0;\n            pagePromise = getNextPagePromise(pageResult);\n            return pagePromise.then(iterate);\n        }\n        return { value: undefined, done: true };\n    }\n    function asyncIteratorNext() {\n        return memoizedPromise(promiseCache, (resolve, reject) => {\n            return pagePromise\n                .then(iterate)\n                .then(resolve)\n                .catch(reject);\n        });\n    }\n    const autoPagingEach = makeAutoPagingEach(asyncIteratorNext);\n    const autoPagingToArray = makeAutoPagingToArray(autoPagingEach);\n    const autoPaginationMethods = {\n        autoPagingEach,\n        autoPagingToArray,\n        // Async iterator functions:\n        next: asyncIteratorNext,\n        return: () => {\n            // This is required for `break`.\n            return {};\n        },\n        [getAsyncIteratorSymbol()]: () => {\n            return autoPaginationMethods;\n        },\n    };\n    return autoPaginationMethods;\n}\n/**\n * ----------------\n * Private Helpers:\n * ----------------\n */\nfunction getAsyncIteratorSymbol() {\n    if (typeof Symbol !== 'undefined' && Symbol.asyncIterator) {\n        return Symbol.asyncIterator;\n    }\n    // Follow the convention from libraries like iterall: https://github.com/leebyron/iterall#asynciterator-1\n    return '@@asyncIterator';\n}\nfunction getDoneCallback(args) {\n    if (args.length < 2) {\n        return null;\n    }\n    const onDone = args[1];\n    if (typeof onDone !== 'function') {\n        throw Error(`The second argument to autoPagingEach, if present, must be a callback function; received ${typeof onDone}`);\n    }\n    return onDone;\n}\n/**\n * We allow four forms of the `onItem` callback (the middle two being equivalent),\n *\n *   1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n *   2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n *   3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n *   4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n *\n * In addition to standard validation, this helper\n * coalesces the former forms into the latter form.\n */\nfunction getItemCallback(args) {\n    if (args.length === 0) {\n        return undefined;\n    }\n    const onItem = args[0];\n    if (typeof onItem !== 'function') {\n        throw Error(`The first argument to autoPagingEach, if present, must be a callback function; received ${typeof onItem}`);\n    }\n    // 4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n    if (onItem.length === 2) {\n        return onItem;\n    }\n    if (onItem.length > 2) {\n        throw Error(`The \\`onItem\\` callback function passed to autoPagingEach must accept at most two arguments; got ${onItem}`);\n    }\n    // This magically handles all three of these usecases (the latter two being functionally identical):\n    // 1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n    // 2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n    // 3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n    return function _onItem(item, next) {\n        const shouldContinue = onItem(item);\n        next(shouldContinue);\n    };\n}\nfunction getLastId(listResult, reverseIteration) {\n    const lastIdx = reverseIteration ? 0 : listResult.data.length - 1;\n    const lastItem = listResult.data[lastIdx];\n    const lastId = lastItem && lastItem.id;\n    if (!lastId) {\n        throw Error('Unexpected: No `id` found on the last item while auto-paging a list.');\n    }\n    return lastId;\n}\n/**\n * If a user calls `.next()` multiple times in parallel,\n * return the same result until something has resolved\n * to prevent page-turning race conditions.\n */\nfunction memoizedPromise(promiseCache, cb) {\n    if (promiseCache.currentPromise) {\n        return promiseCache.currentPromise;\n    }\n    promiseCache.currentPromise = new Promise(cb).then((ret) => {\n        promiseCache.currentPromise = undefined;\n        return ret;\n    });\n    return promiseCache.currentPromise;\n}\nfunction makeAutoPagingEach(asyncIteratorNext) {\n    return function autoPagingEach( /* onItem?, onDone? */) {\n        const args = [].slice.call(arguments);\n        const onItem = getItemCallback(args);\n        const onDone = getDoneCallback(args);\n        if (args.length > 2) {\n            throw Error(`autoPagingEach takes up to two arguments; received ${args}`);\n        }\n        const autoPagePromise = wrapAsyncIteratorWithCallback(asyncIteratorNext, \n        // @ts-ignore we might need a null check\n        onItem);\n        return callbackifyPromiseWithTimeout(autoPagePromise, onDone);\n    };\n}\nfunction makeAutoPagingToArray(autoPagingEach) {\n    return function autoPagingToArray(opts, onDone) {\n        const limit = opts && opts.limit;\n        if (!limit) {\n            throw Error('You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.');\n        }\n        if (limit > 10000) {\n            throw Error('You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.');\n        }\n        const promise = new Promise((resolve, reject) => {\n            const items = [];\n            autoPagingEach((item) => {\n                items.push(item);\n                if (items.length >= limit) {\n                    return false;\n                }\n            })\n                .then(() => {\n                resolve(items);\n            })\n                .catch(reject);\n        });\n        // @ts-ignore\n        return callbackifyPromiseWithTimeout(promise, onDone);\n    };\n}\nfunction wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {\n    return new Promise((resolve, reject) => {\n        function handleIteration(iterResult) {\n            if (iterResult.done) {\n                resolve();\n                return;\n            }\n            const item = iterResult.value;\n            return new Promise((next) => {\n                // Bit confusing, perhaps; we pass a `resolve` fn\n                // to the user, so they can decide when and if to continue.\n                // They can return false, or a promise which resolves to false, to break.\n                onItem(item, next);\n            }).then((shouldContinue) => {\n                if (shouldContinue === false) {\n                    return handleIteration({ done: true });\n                }\n                else {\n                    return asyncIteratorNext().then(handleIteration);\n                }\n            });\n        }\n        asyncIteratorNext()\n            .then(handleIteration)\n            .catch(reject);\n    });\n}\nfunction isReverseIteration(requestArgs) {\n    const args = [].slice.call(requestArgs);\n    const dataFromArgs = getDataFromArgs(args);\n    return !!dataFromArgs.ending_before;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}